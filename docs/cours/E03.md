# API E03 - REST & CRUD (partie 1)

## Menu du jour

```
=== Matin COURS ===

- Correction
  - Modèles Sequelize & Scripts (Cards & Tags)
  - API REST : routes /lists

- Bonnes pratiques API
  - Validations des entrées 
  - Gestion des erreurs 
  - Testing HTTP (Insomnia)

=== Aprem ATELIER ===

- API REST : /cards & /tags endpoints
```



## Verbes HTTP

Verbes HTTP (**conventions**)
- `GET` : récupérer des ressources
- `POST` : créer des ressources
- `DELETE` : supprimer des ressources
- `PATCH` : modifier (partiellement) des ressources
- `PUT` : remplacer (complètement) des ressources

L'un convention des **API REST** sont de respecter le choix du verbe pour l'action utilisateur.

Ex de API REST qui respecte bien cette convention du verbe 

## Conventions sur les endpoints = routes 

Nom de la ressource au **pluriel** !

- `GET /playlists/:id` : récupérer une playlists
- `GET /playlists` : récupérer toutes les playlists
- `POST /playlists` : créer une playlist
- `PATCH /playlists/:id` : modifier une playlist
- `GET /artists/:id/albums` : récupérer les albums d'un artiste

Ajouter une tracks dans une playlists :
- ✅ `POST /playlists/:id/tracks`  || BODY = { url_de_la_tracks }
- (valide également) `POST /tracks`  || BODY = {url_de_la_tracks + playlist_id}


## Extension VSCode

- Markdown All In One
  - afin de pouvoir interpréter les markdown dans VSCode

- Ouvrir ensuite un markdown
  - `CTRL + SHIFT + P`
  - `Markdown: Open Preview to the Side`


## Pourquoi coder une API ? 

Et quel est l'avantage par rapport à une architecture `Server-side rendering` ?


### Server-side-rendering

Avantages : 
- **Complexité** : Architecture "simple" : tout est géré par un seul serveur qui calcul aussi le rendu HTML
- **Performance** : Un seul appel au serveur contrairement à l'autre architecture
- **SEO** : le serveur nous renvoie un fichier HTML **contenenant les données** => ça fiat des choses à indexer par les moteurs de recherche

Inconvénients : 
- **Dynamisme**/**Performance** : on doit RECHARGER la page à chaque update. (ex : ajouter un nouveau level => `res.redirect()`) 
- **SoC** : le serveur "backend" s'occupe aussi de la view (`render`)

=> adapté pour un site vitrine avec peu d'intéraction avec la base de données

### Architecture Client-serveur

Avantages :
- **SoC** : l'API ne s'occupe QUE de l'interface avec la BDD (sans la partie visuelle)
  - facilite l'ajout de différents frontend : front navigateur / app mobile / code d'assistant vocal / bot discord / ...
- **Reactivité** : 
  - ex : infinity scroll
  - ex : edition d'un level sans recharger la page
  - ex : ajout dans GitHub Project d'une nouvelle carte => pas de rechargement de la page

Inconvénients : 
- **SEO** : le navigateur reçoit une coquille vide (pas de données) => rien à indexer (les moteurs de recherche **n'exécute pas le JavaScript**)
- **Complexité** : deux serveurs à gérer, deux codes bien distincts à maintenir : le code back (API) + le/les codes front

=> adapté pour un site complexe de gestion de données (ex : application RH)



## `Sequelize.sync()` ou `SQL` ?

Conseil : au TP, faite tout de même le script SQL car vos compétences SQL doivent être évaluée.

Dans la vie : **KISS** ! 



## Status code

Le status code que renvoie une réponse d'API permet aux développeurs qui utilisent l'API de déterminer si tout s'est bien passé, ou bien, dans le cas où il y a eu une erreur, comprendre l'erreur : 

- `4XX` : erreur client 
  - le code qui fait la requête ne passe pas les critères du serveur
    - `404` (Not Found) : ta ressource là que tu me demandes n'existe pas
    - `400` (Bad Request) : t'essaie de créer une liste mais tu ne me donne pas de title, c'est pas bon !
    - `401` (Unauthorized) : tu essaie d'accéder à la page des /quiz/id mais tu n'est pas connecté !
    - `403` (Forbbiden) : tu essaie d'accéder à la page des /levels, tu es bien connecté mais tu n'est pas admin !

- `5XX` : erreur serveur 
  - le code front n'y est pour rien, c'est le serveur qui fait des bétises : 
    - ex : la BDD chez OVH est en train de cramer
    - ex : les dev ont écrit `List.findById()` plutôt que `List.findByPk()` donc le code serveur plante (ils sont cons ces devs...)


## Body validator

Exemples : 
- Joi
- Zod
- AJV

## Git Flow

Git Flow puis au lit

- Sauvegarder le code de votre branche `jour2` :
  - `git add .`
  - `git commit -m "..."`
  - `git push`
  - `git status` (tout doit être clean)

- Retourner sur votre branche `master` : 
  - `git checkout master`

- Vérifier que le remote "prof" existe 
  - `git remote -v` : 4 lignes s'affichent dont 2 "prof"

- Récupérer les branche du prof 
  - `git fetch prof`
  - (note : le fetch n'intègre pas les changement dans la branche courante)

- Ecraser le contenu du master par le main du prof 
  - `git reset --hard prof/main`
  - (sous contrôle d'un professionnel)

- Penser à créer une branche pour le jour 3
  - `git checkout -b jour3`
