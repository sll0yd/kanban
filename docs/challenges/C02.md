# O'Kanban - API E02 - Atelier Modèles et début API

[Rappel : lien pour créer des issues](https://github.com/O-clock-Quinoa/Soutien-ateliers/issues)

## Étape 1 - Mise en place `Git`

Si cela n'a pas été fait en cours, suivre attentivement le [Git Flow](../resources/gitflow.md) pour récupérer la correction "prof" et créer une branche `jour2` pour la seconde journée.

## Challenge

---

⚠️ **Les deux parties suivantes sont indépendantes.** ⚠️

---


## Étape 2 - Modélisation `Sequelize`

### 2.1. Définition des modèles

Ajouter les **modèles** Sequelize pour les `Card` et `Tag` dans le dossier `src/models/` en suivant les spécifications du MLD.

Notes : 
- pas besoin de préciser les clés étrangères et/ou tables de liaison, on s'en occupe à la prochaine étape.
- on ne peut pas tester le modèle tant que les tables ne sont pas créées. Il va falloir patienter un peu.

### 2.2. Définition des associations

Définir les **associations** entre les modèles `List`, `Tag`, `Card` dans un fichier séparé `src/models/associations.js` en suivant la documentation Sequelize et les exemples des cours précédents.

Pensez ensuite à ré-exporter vos modèles depuis ce fichier : désormais, on importera les modèles depuis le fichier d'association afin de profiter des jointures (`include`) entre les tables.

⚠️ Enfin, il faudra également créer (en plus) un modèle dédié pour la table de liaison (`CardHasTag`), afin de pouvoir la synchroniser dans l'étape suivante. Une implémentation possible est, par exemple :


```js
// @file src/models/associations.js
import { sequelize } from "./sequelizeClient.js"; // Notre instance de connexion

// ...

export const CardHasTag = sequelize.define("card_has_tag", {}, { tableName: "card_has_tag" });

// Suivi du reste de la définition de l'association entre le modèle Card et le model Tag
```

### 2.3. (Bonus) Création des tables

Modifier le fichier `src/migrations/01.createTables.js` afin de compléter la création des tables via nos modèles Sequelize :

- à l'aide des méthodes `Model.sync()` et `Model.drop()`, il est temps de créer l'intégralité des tables dans la BDD ;
- penser à les supprimer (dans le bon ordre !) avant de les re-synchroniser (dans le bon ordre !) ;
- penser à exécuter le script pour tester son bon fonctionnement et confirmer via `psql` que les tables sont bien créées en BDD ;
  - les commandes `\dt` et `\d nom_de_table` sont bien pratiques pour cela !

### 2.4. (Bonus) Échantillonnage

Modifier le fichier `src/migrations/02.seedTables.js` afin de compléter la génération de l'échantillon de test, en ajoutant quelques exemples de listes, cartes et de tags, à relier les unes aux autres.

### 2.5. (Bonus) Scripts NPM

Ajouter trois scripts au `package.json` pour faciliter la ré-initialisation de la base de données pour les jours suivants.
- `npm run db:create` : qui lance le script de création de tables ;
- `npm run db:seed` : qui lance le script d’échantillonnage :
- `npm run db:reset` : qui lance les deux scripts précédents.

### 2.6. Remarque finale

Nous avons implémenté notre modèle physique de données (MPD) via nos modèles Sequelize. 

Si l'envi vous prend de pratiquer l'écriture du script SQL équivalent (création de toutes les tables et contraintes entre elles, en SQL), profitez-en sur les jours à venir !


## Étape 3 - API REST

À l'aide des [spécifications des routes `/lists`](../resources/api-lists-specifications.md) fournies, implémenter les routes suivantes dans l'API :

- `GET /lists`
- `GET /lists/:id`
- `POST /lists`
- `PATCH /lists/:id`
- `DELETE /lists/:id`

Notes :

- pensez à tester régulièrement vos routes pour tester leur bon fonctionnement, à l'aide d'un **client HTTP** de votre choix : `Insomnia`, `Postman`, `cURL`, `Chrome` pour les `GET`…
- la gestion des erreurs (et des codes d'erreurs) peut être réalisée dans un second temps. En cas de difficulté, on se concentre sur le bon fonctionnement du cas d'usage de base !
- les messages d'erreurs à fournir au client sont donnés à titre indicatif. N'hésitez pas à adapter leurs libellés si vous le souhaitez.
